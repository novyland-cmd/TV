<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Qui √©coute quoi ?</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0c10; color: #e9eef6; }
    header { padding: 18px 16px; border-bottom: 1px solid rgba(255,255,255,.08); }
    h1 { margin: 0; font-size: 18px; font-weight: 700; }
    main { padding: 16px; max-width: 1050px; margin: 0 auto; }
    .grid { display: grid; gap: 12px; }
    .card { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.10); border-radius: 12px; padding: 14px; }
    .row { display: grid; gap: 10px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .row { grid-template-columns: 2fr 1.4fr 1.2fr 1.2fr auto; align-items: end; } }
    label { font-size: 12px; opacity: .85; display:block; margin-bottom: 6px; }
    input, select, button { width: 100%; box-sizing: border-box; }
    input, select {
      background: rgba(0,0,0,.25);
      color: #e9eef6;
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 10px;
      padding: 10px 10px;
      outline: none;
    }
    input:focus, select:focus { border-color: rgba(120,170,255,.85); box-shadow: 0 0 0 3px rgba(120,170,255,.15); }
    button {
      border: 0; border-radius: 10px; padding: 10px 12px;
      cursor: pointer; font-weight: 650;
      background: #2b6cff; color: white;
    }
    button.secondary { background: rgba(255,255,255,.12); color: #e9eef6; }
    button.danger { background: rgba(255,80,80,.18); color: #ffb7b7; border: 1px solid rgba(255,80,80,.35); }
    .toolbar { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .toolbar > * { flex: 1; min-width: 170px; }
    .toolbar .tight { flex: 0 0 auto; min-width: auto; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 10px; border-bottom: 1px solid rgba(255,255,255,.08); vertical-align: top; }
    th { font-size: 12px; opacity: .9; }
    td { font-size: 14px; }
    .pill {
      display:inline-flex; gap:6px; align-items:center;
      padding: 4px 10px; border-radius: 999px;
      background: rgba(255,255,255,.10); border: 1px solid rgba(255,255,255,.12);
      font-size: 12px;
      white-space: nowrap;
    }
    .muted { opacity: .75; }
    .actions { display:flex; gap:8px; justify-content: flex-end; flex-wrap: wrap; }
    .actions button { width:auto; }
    .empty { padding: 10px 0; opacity: .8; }
    footer { padding: 14px 16px; opacity: .7; font-size: 12px; }
    .hint { font-size: 12px; opacity: .8; margin-top: 8px; }
    .statusline { margin-top: 10px; font-size: 12px; opacity: .9; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .ok { color: #9be39b; }
    .warn { color: #ffd28a; }
    .err { color: #ff9a9a; }
    .tiny { font-size: 12px; opacity:.8; }
    .icon-btn {
  background: transparent;
  border: none;
  padding: 6px;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  border-radius: 8px;
  opacity: 0.85;
}

.icon-btn:hover {
  background: rgba(255,255,255,.12);
  opacity: 1;
}

.icon-btn.danger:hover {
  background: rgba(255,80,80,.18);
}
  </style>
</head>

<body>
<header>
  <h1>üì∫ Qui √©coute quoi ? (Louise & Yvon)</h1>
</header>

<main class="grid">
  <section class="card">
    <div class="row">
      <div>
        <label for="title">Titre de la s√©rie</label>
        <input id="title" type="text" placeholder="ex. Severance" autocomplete="off" />
      </div>

<div>
  <label for="platform">Plateforme</label>
  <select id="platform">
    <option value="">‚Äî Choisir ‚Äî</option>
    <option value="Cogeco">Cogeco</option>
    <option value="Netflix">Netflix</option>
    <option value="Tou.TV">Tou.TV</option>
    <option value="illico+">illico+</option>
    <option value="Prime">Prime</option>
    <option value="Crave">Crave</option>
    <option value="Apple TV+">Apple TV+</option>
    <option value="Disney+">Disney+</option>
    <option value="YouTube">YouTube</option>
  </select>
</div>
      <div>
        <label for="who">Qui √©coute ?</label>
        <select id="who">
          <option value="Louise">Louise</option>
          <option value="Yvon">Yvon</option>
          <option value="Ensemble">Ensemble</option>
        </select>
      </div>

      <div>
        <label for="status">Statut</label>
        <select id="status">
          <option value="√Ä commencer">√Ä commencer</option>
          <option value="En cours">En cours</option>
          <option value="Termin√©">Termin√©</option>
        </select>
      </div>

      <div class="actions">
        <button id="saveBtn">Ajouter</button>
        <button id="cancelEditBtn" class="secondary" style="display:none;">Annuler</button>
      </div>
    </div>

    <div class="hint muted">Astuce: <b>Ensemble</b> compte pour Louise + Yvon dans les filtres.</div>
    <div id="syncStatus" class="statusline">
      <span>Connexion: <span class="warn">en cours‚Ä¶</span></span>
      <span class="tiny">File d‚Äôattente: <b id="queueCount">0</b></span>
    </div>
  </section>

  <section class="card">
    <div class="toolbar">
      <div>
        <label for="search">Recherche</label>
        <input id="search" type="text" placeholder="Titre, plateforme, qui, statut..." autocomplete="off" />
      </div>

      <div>
        <label for="filterWho">Filtrer (qui)</label>
        <select id="filterWho">
          <option value="all">Tous</option>
          <option value="Louise">Louise (inclut Ensemble)</option>
          <option value="Yvon">Yvon (inclut Ensemble)</option>
          <option value="Ensemble">Ensemble seulement</option>
        </select>
      </div>

      <div>
        <label for="filterStatus">Filtrer (statut)</label>
        <select id="filterStatus">
          <option value="all">Tous</option>
          <option value="√Ä commencer">√Ä commencer</option>
          <option value="En cours">En cours</option>
          <option value="Termin√©">Termin√©</option>
        </select>
      </div>

      <div class="tight" style="display:flex; gap:10px; align-items:end;">
        <button id="reloadBtn" class="secondary" title="Recharger depuis Google Sheets">Recharger</button>
        <button id="exportBtn" class="secondary" title="Copier les donn√©es en JSON">Exporter</button>
      </div>
    </div>
  </section>

  <section class="card">
    <table>
      <thead>
        <tr>
          <th style="width:40%;">S√©rie</th>
          <th style="width:22%;">Plateforme</th>
          <th style="width:12%;">Qui</th>
          <th style="width:14%;">Statut</th>
          <th style="width:12%; text-align:right;">Actions</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <div id="empty" class="empty" style="display:none;">Aucune s√©rie ici‚Ä¶ le canap√© a faim üçø</div>
  </section>
</main>

<footer>
  Version 1.0
</footer>

<script>
(() => {
  // ‚úÖ Colle ici ton URL Apps Script (se termine par /exec)
  const API_URL = "https://script.google.com/macros/s/AKfycbyyOsZQma7wf5op2rfAHntRG9SzfSKB4Tbbz4ObEjdxHIS2RXDr7C814ojBccbo4rFr/exec";

  // --- State ---
  let items = [];
  let editingId = null;

  // Queue: id -> { type: "upsert"|"delete", payload, seq }
  const pendingMap = new Map();
  let seq = 0;
  let flushing = false;

  // DOM
  const titleEl = document.getElementById("title");
  const platformEl = document.getElementById("platform");
  const whoEl = document.getElementById("who");
  const statusEl = document.getElementById("status");
  const saveBtn = document.getElementById("saveBtn");
  const cancelEditBtn = document.getElementById("cancelEditBtn");

  const searchEl = document.getElementById("search");
  const filterWhoEl = document.getElementById("filterWho");
  const filterStatusEl = document.getElementById("filterStatus");

  const tbody = document.getElementById("tbody");
  const emptyEl = document.getElementById("empty");

  const reloadBtn = document.getElementById("reloadBtn");
  const exportBtn = document.getElementById("exportBtn");

  const syncStatusEl = document.getElementById("syncStatus");
  const queueCountEl = document.getElementById("queueCount");

  // --- API (Apps Script) ---
  async function apiList() {
    const res = await fetch(`${API_URL}?action=list`, { method: "GET" });
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("API list: r√©ponse inattendue");
    return data;
  }

  async function apiUpsert(item) {
    const body = new URLSearchParams();
    body.set("action", "upsert");
    body.set("id", item.id || "");
    body.set("title", item.title || "");
    body.set("platform", item.platform || "");
    body.set("who", item.who || "Louise");
    body.set("status", item.status || "√Ä commencer");

    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body
    });
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || "API upsert: √©chec");
    return data.item;
  }

  async function apiDelete(id) {
    const body = new URLSearchParams();
    body.set("action", "delete");
    body.set("id", id);

    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body
    });
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || "API delete: √©chec");
    return data.deleted;
  }

  // --- Helpers ---
  function uuid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }
  function normalize(s) { return (s || "").trim(); }
  function escapeHtml(str) {
    return (str || "").replace(/[&<>"']/g, (ch) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[ch]));
  }
  function setSyncStatus(kind, msg) {
    const cls = kind === "ok" ? "ok" : kind === "err" ? "err" : "warn";
    syncStatusEl.querySelector("span").innerHTML = `Connexion: <span class="${cls}">${escapeHtml(msg)}</span>`;
  }
  function updateQueueCount() {
    queueCountEl.textContent = String(pendingMap.size);
  }

  function whoEmoji(who) {
    if (who === "Louise") return "üë©";
    if (who === "Yvon") return "üë®";
    return "üë•";
  }
  function statusEmoji(status) {
    if (status === "√Ä commencer") return "üÜï";
    if (status === "En cours") return "‚è≥";
    return "‚úÖ";
  }

  function matchesWho(item, filterValue) {
    if (filterValue === "all") return true;
    if (filterValue === "Ensemble") return item.who === "Ensemble";
    return item.who === filterValue || item.who === "Ensemble";
  }
  function matchesStatus(item, filterValue) {
    if (filterValue === "all") return true;
    return item.status === filterValue;
  }
  function matchesSearch(item, q) {
    if (!q) return true;
    const hay = (item.title + " " + item.platform + " " + item.who + " " + item.status).toLowerCase();
    return hay.includes(q.toLowerCase());
  }
function sortItems(a, b) {
  const t = (a.title || "").localeCompare(
    (b.title || ""),
    "fr",
    { sensitivity: "base" }
  );
  if (t !== 0) return t;

  // secondaire optionnel: plateforme
  return (a.platform || "").localeCompare(
    (b.platform || ""),
    "fr",
    { sensitivity: "base" }
  );
}

  function setEditMode(id) {
    editingId = id;
    const item = items.find(x => x.id === id);
    if (!item) return;

    titleEl.value = item.title || "";
    platformEl.value = item.platform || "";
    whoEl.value = item.who || "Louise";
    statusEl.value = item.status || "√Ä commencer";

    saveBtn.textContent = "Enregistrer";
    cancelEditBtn.style.display = "inline-block";
    titleEl.focus();
  }

  function exitEditMode() {
    editingId = null;
    saveBtn.textContent = "Ajouter";
    cancelEditBtn.style.display = "none";
    titleEl.value = "";
    platformEl.value = "";
    whoEl.value = "Louise";
    statusEl.value = "√Ä commencer";
  }

  // --- Local upsert/delete (optimistic) ---
  function upsertLocal(draft) {
    const idx = items.findIndex(x => x.id === draft.id);
    if (idx >= 0) items[idx] = { ...items[idx], ...draft };
    else items.push(draft);
  }

  function deleteLocal(id) {
    items = items.filter(x => x.id !== id);
  }

  // --- Queue + flush (last-write-wins per id) ---
  function enqueueUpsert(draft) {
    const key = draft.id;
    pendingMap.set(key, { type: "upsert", payload: draft, seq: ++seq });
    updateQueueCount();
    flushSoon();
  }

  function enqueueDelete(id) {
    pendingMap.set(id, { type: "delete", payload: { id }, seq: ++seq });
    updateQueueCount();
    flushSoon();
  }

  let flushTimer = null;
  function flushSoon() {
    if (flushing) return;
    clearTimeout(flushTimer);
    // petit debounce pour regrouper les actions rapproch√©es
    flushTimer = setTimeout(flushQueue, 250);
  }

  async function flushQueue() {
    if (flushing) return;
    if (pendingMap.size === 0) return;

    flushing = true;
    setSyncStatus("warn", "synchro‚Ä¶");

    try {
      // Traiter dans l‚Äôordre des seq (mais last-write-wins est d√©j√† garanti par Map)
      const batch = Array.from(pendingMap.entries())
        .map(([id, job]) => ({ id, ...job }))
        .sort((a, b) => a.seq - b.seq);

      for (const job of batch) {
        // V√©rifie que le job est toujours le dernier pour cet id
        const current = pendingMap.get(job.id);
        if (!current || current.seq !== job.seq) continue;

        if (job.type === "delete") {
          await apiDelete(job.id);
          pendingMap.delete(job.id);
        } else {
          const saved = await apiUpsert(job.payload);
          // Optionnel: int√©grer updatedAt renvoy√© par le serveur (sans recharger tout)
          upsertLocal(saved);
          pendingMap.delete(job.id);
        }
        updateQueueCount();
        render(); // l√©ger, mais donne retour visuel imm√©diat
      }

      setSyncStatus("ok", "synchro OK");
    } catch (err) {
      // On garde la queue, l‚Äôutilisateur peut Recharger pour re-sync/diagnostic
      setSyncStatus("err", "synchro en √©chec (queue conserv√©e)");
      console.error(err);
    } finally {
      flushing = false;
      updateQueueCount();
    }
  }

  // --- Render ---
  function render() {
    const q = normalize(searchEl.value);
    const fWho = filterWhoEl.value;
    const fStatus = filterStatusEl.value;

    const filtered = items
      .filter(it => matchesWho(it, fWho))
      .filter(it => matchesStatus(it, fStatus))
      .filter(it => matchesSearch(it, q))
      .slice()
      .sort(sortItems);

    tbody.innerHTML = "";
    emptyEl.style.display = filtered.length === 0 ? "block" : "none";

    for (const it of filtered) {
      const tr = document.createElement("tr");

      const tdTitle = document.createElement("td");
      tdTitle.innerHTML = `<div><b>${escapeHtml(it.title)}</b></div>`;

      const tdPlat = document.createElement("td");
      tdPlat.innerHTML = it.platform
        ? `<span class="muted">${escapeHtml(it.platform)}</span>`
        : `<span class="muted">‚Äî</span>`;

      const tdWho = document.createElement("td");
      tdWho.innerHTML = `<span class="pill">${whoEmoji(it.who)} ${escapeHtml(it.who)}</span>`;

      const tdStatus = document.createElement("td");
      tdStatus.innerHTML = `<span class="pill">${statusEmoji(it.status)} ${escapeHtml(it.status)}</span>`;

      const tdActions = document.createElement("td");
      tdActions.style.textAlign = "right";

      // ‚úèÔ∏è Modifier
      const edit = document.createElement("button");
      edit.className = "icon-btn";
      edit.innerHTML = "‚úèÔ∏è";
      edit.title = "Modifier la s√©rie";
      edit.addEventListener("click", () => setEditMode(it.id));

      // üóëÔ∏è Supprimer
      const del = document.createElement("button");
      del.className = "icon-btn danger";
      del.innerHTML = "üóëÔ∏è";
      del.title = "Supprimer la s√©rie";
      del.addEventListener("click", () => {
        const ok = confirm(`Supprimer "${it.title}" ?`);
        if (!ok) return;

        // Optimistic delete
        deleteLocal(it.id);
        if (editingId === it.id) exitEditMode();
        render();

        // Suppression en arri√®re-plan
        enqueueDelete(it.id);
      });

      const wrap = document.createElement("div");
      wrap.className = "actions";
      wrap.append(edit, del);

      tdActions.appendChild(wrap);

      tr.append(tdTitle, tdPlat, tdWho, tdStatus, tdActions);
      tbody.appendChild(tr);
    }
  }

  // --- Actions ---
  function addOrUpdateOptimistic() {
    const title = normalize(titleEl.value);
    const platform = normalize(platformEl.value);
    const who = whoEl.value;
    const status = statusEl.value;

    if (!title) {
      alert("Ajoute au moins un titre üôÇ");
      titleEl.focus();
      return;
    }

    // Id: en ajout, on g√©n√®re un id tout de suite (optimistic)
    const id = editingId || uuid();

    // Emp√™che duplicata exact en mode ajout (m√™me titre + m√™me who)
    if (!editingId) {
      const exists = items.some(x =>
        (x.title || "").toLowerCase() === title.toLowerCase() &&
        x.who === who
      );
      if (exists) {
        alert("Cette s√©rie existe d√©j√† avec ce m√™me 'qui √©coute'.");
        return;
      }
    }

    const draft = { id, title, platform, who, status, updatedAt: Date.now() };

    // ‚úÖ Optimistic: update local + UI instant
    upsertLocal(draft);
    render();

    // ‚úÖ Enqueue write (last-write-wins)
    enqueueUpsert(draft);

    exitEditMode();
    titleEl.focus();
  }

  async function reloadFromServer() {
    if (!API_URL || API_URL.includes("COLLE_ICI")) {
      setSyncStatus("err", "API_URL manquant (colle ton /exec)");
      return;
    }

    try {
      setSyncStatus("warn", "rechargement‚Ä¶");
      const serverItems = await apiList();

      // On conserve les changements locaux non envoy√©s en priorit√© (optimistic)
      const localPendingIds = new Set(pendingMap.keys());
      const merged = [];

      // 1) items serveur
      for (const s of serverItems) merged.push(s);

      // 2) r√©appliquer les pending (upsert/delete) par-dessus
      for (const [id, job] of pendingMap.entries()) {
        if (job.type === "delete") {
          // supprimer de merged
          for (let i = merged.length - 1; i >= 0; i--) {
            if (merged[i].id === id) merged.splice(i, 1);
          }
        } else {
          // upsert par-dessus
          const idx = merged.findIndex(x => x.id === id);
          if (idx >= 0) merged[idx] = { ...merged[idx], ...job.payload };
          else merged.push(job.payload);
        }
      }

      items = merged;
      render();
      setSyncStatus("ok", localPendingIds.size ? "recharg√© (modifs locales conserv√©es)" : "synchro OK");
    } catch (err) {
      setSyncStatus("err", "impossible de se connecter");
      alert("Impossible de recharger.\n\n" + err);
    }
  }

  // Events
  saveBtn.addEventListener("click", addOrUpdateOptimistic);
  cancelEditBtn.addEventListener("click", exitEditMode);

  searchEl.addEventListener("input", render);
  filterWhoEl.addEventListener("change", render);
  filterStatusEl.addEventListener("change", render);

  reloadBtn.addEventListener("click", reloadFromServer);

  exportBtn.addEventListener("click", async () => {
    const json = JSON.stringify(items, null, 2);
    try {
      await navigator.clipboard.writeText(json);
      alert("Export JSON copi√© ‚úÖ");
    } catch {
      prompt("Copie ce JSON:", json);
    }
  });

  // Init
  (async () => {
    if (!API_URL || API_URL.includes("COLLE_ICI")) {
      setSyncStatus("err", "API_URL manquant (colle ton /exec)");
      render();
      return;
    }

    setSyncStatus("warn", "chargement‚Ä¶");
    await reloadFromServer();

    // flush automatique p√©riodique, au cas o√π (ex. r√©seau qui revient)
    setInterval(() => { if (pendingMap.size) flushSoon(); }, 2000);
  })();
})();
</script>
</body>
</html>
